#!/usr/bin/env bpftrace

/* * rx_lat_hist_udp.bt
 * Measures Receiver Latency for UDP using Histograms.
 */

/* 1. DRIVER LAYER (Start) */
tracepoint:net:netif_receive_skb
{
    $skb = (uint64)args->skbaddr;
    @rx_start[$skb] = nsecs;
}

/* 2. IP LAYER (Routing) */
kprobe:ip_local_deliver
{
    $skb = (uint64)arg0;
    if (@rx_start[$skb]) {
        @rx_ip[$skb] = nsecs;
    }
}

/* 3. SOCKET LAYER (End) - Back to UDP Specific */
kprobe:udp_queue_rcv_skb
{
    $skb = (uint64)arg1; 
    
    if (@rx_start[$skb]) {
        $start = @rx_start[$skb];
        $ip_ts = @rx_ip[$skb];
        $now = nsecs;

        // Calculate latencies in MICROSECONDS
        if ($ip_ts != 0) {
             $drv_ip  = ($ip_ts - $start) / 1000;
             $ip_sock = ($now - $ip_ts)  / 1000;
             $total   = ($now - $start)  / 1000;
             
             @dist_Driver_to_IP_us = hist($drv_ip);
             @dist_IP_to_Socket_us = hist($ip_sock);
             @dist_Total_Latency_us = hist($total);
             
             // Use a separate aggregator for the average
             @avg_latency_total = avg($total);
        }

        delete(@rx_start[$skb]);
        delete(@rx_ip[$skb]);
    }
}

/* Print summary every 5 seconds */
interval:s:5 {
    time("%H:%M:%S \n");
    

    print(@dist_Total_Latency_us);
    
    // Print the calculated average
    printf("DATA_AVG_LATENCY_US: ");
    print(@avg_latency_total);
    
    // Clear distributions
    clear(@dist_Driver_to_IP_us);
    clear(@dist_IP_to_Socket_us);
    clear(@dist_Total_Latency_us);
    clear(@avg_latency_total);


}