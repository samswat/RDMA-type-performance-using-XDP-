#!/usr/bin/env bpftrace

/* * rx_lat_tcp_udp.bt
 * Measures Latency for both TCP and UDP packets.
 */

/* 1. DRIVER LAYER - Packet enters the system */
tracepoint:net:netif_receive_skb
{
    $skb = (uint64)args->skbaddr;
    @rx_start[$skb] = nsecs;
}

/* 2. IP LAYER - Routing decision made */
kprobe:ip_local_deliver
{
    $skb = (uint64)arg0;
    if (@rx_start[$skb]) {
        @rx_ip[$skb] = nsecs;
    }
}

/* 3. SOCKET LAYER - Generic hook for TCP/UDP/Raw sockets */
kprobe:sock_queue_rcv_skb
{
    $skb = (uint64)arg1; 
    
    if (@rx_start[$skb]) {
        $start = @rx_start[$skb];
        $ip_ts = @rx_ip[$skb];
        $now = nsecs;

        if ($ip_ts != 0) {
             $drv_ip  = ($ip_ts - $start) / 1000;
             $ip_sock = ($now - $ip_ts)  / 1000;
             $total   = ($now - $start)  / 1000;
             
             @dist_Driver_to_IP_us = hist($drv_ip);
             @dist_IP_to_Socket_us = hist($ip_sock);
             @dist_Total_Latency_us = hist($total);
        }

        delete(@rx_start[$skb]);
        delete(@rx_ip[$skb]);
    }
}

/* Periodic Report & Memory Cleanup */
interval:s:5 {
    time("%H:%M:%S \n");
    
    print(@dist_Driver_to_IP_us);
    print(@dist_IP_to_Socket_us);
    print(@dist_Total_Latency_us);
    
    clear(@dist_Driver_to_IP_us);
    clear(@dist_IP_to_Socket_us);
    clear(@dist_Total_Latency_us);

    /* * Cleanup: If a packet was dropped before reaching the socket,
     * it stays in @rx_start. We clear the map to prevent leaks.
     */
    clear(@rx_start);
    clear(@rx_ip);
}