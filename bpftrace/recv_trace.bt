#!/usr/bin/env bpftrace

/* * TRACING RECEIVER LATENCY (The Upward Path)
 * * Path: [Driver] --> [IP Layer] --> [Socket/App]
 */

BEGIN
{
    printf("Tracing Receiver Stack Latency... Hit Ctrl+C to stop.\n");
    printf("%-18s %-12s %-12s %-12s\n", "SKB_ADDR", "DRV->IP(us)", "IP->SOCK(us)", "TOTAL(us)");
}

/* * 1. DRIVER LAYER (Start of Kernel Work)
 * The NIC driver hands the packet to the Generic Kernel Stack.
 */
tracepoint:net:netif_receive_skb
{
    $skb = (uint64)args->skbaddr;
    @rx_start[$skb] = nsecs;
}

/* * 2. IP LAYER (Routing Decision)
 * The packet has passed firewall checks and routing. 
 * It is now determined to be "Local" (for this machine).
 */
kprobe:ip_local_deliver
{
    $skb = (uint64)arg0; // First argument is skb
    if (@rx_start[$skb]) {
        @rx_ip[$skb] = nsecs;
    }
}

/* * 3. SOCKET LAYER (End of Kernel Work)
 * The packet is enqueued into the UDP socket.
 * This is effectively "send" but in reverseâ€”it's ready for the app.
 */
kprobe:udp_queue_rcv_skb
{
    $skb = (uint64)arg1; // First arg is sock, second is skb
    
    if (@rx_start[$skb]) {
        $start = @rx_start[$skb];
        $ip_ts = @rx_ip[$skb]; // Retrieve IP layer timestamp
        $now = nsecs;

        // Only calculate if we caught the middle step (IP Layer)
        if ($ip_ts != 0) {
             $lat_drv_ip  = ($ip_ts - $start) / 1000;
             $lat_ip_sock = ($now - $ip_ts)  / 1000;
             $total       = ($now - $start)  / 1000;
             
             printf("0x%-16lx %-12d %-12d %-12d\n", 
                    $skb, $lat_drv_ip, $lat_ip_sock, $total);
        }

        // Cleanup
        delete(@rx_start[$skb]);
        delete(@rx_ip[$skb]);
    }
}

/* Cleanup to prevent memory leaks */
interval:s:5 {
    clear(@rx_start);
    clear(@rx_ip);
}